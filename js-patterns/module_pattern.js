/**
 * Шаблон «модуль»
 * http://yuiblog.com/blog/2007/06/12/module-pattern/
 * http://christianheilmann.com/2007/08/22/again-with-the-module-pattern-reveal-something-to-the-world/
 *
 */

// Шаблон «модуль» является комбинацией нескольких шаблонов, а именно:
// - Пространств имен
// - Немедленно вызываемых функций
// - Частных и привилегированных членов
// - Объявления зависимостей


var MYAPP = MYAPP || {};

// Функция создания пространства имен
MYAPP.namespace = function (ns_string) {
    var parts = ns_string.split('.'),
        parent = MYAPP,
        i;
    // отбросить начальный префикс – имя глобального объекта
    if (parts[0] === 'MYAPP') {
        parts = parts.slice(1);
    }
    for (i = 0; i < parts.length; i += 1) {
        // создать свойство, если оно отсутствует
        if (typeof parent[parts[i]] === 'undefined') {
            parent[parts[i]] = {};
        }
        parent = parent[parts[i]];
    }
    return parent;
};

// Создание пространства имен
MYAPP.namespace('MYAPP.utilities.array');

// Определение модуля. На этом этапе используется немедленно вызываемая функция, образующая частную область видимости,
// если это необходимо. Немедленно вызываемая функция возвращает объект – собственно модуль с общедоступным интерфейсом,
// который может использоваться программами, в которые добавляется модуль.

MYAPP.utilities.array = (function () {
    // В самом начале немедленно вызываемой функции следует поместить все объявления зависимостей, необходимых для модуля.

    // В частной области видимости, образуемой немедленно вызываемой функцией, можно объявить частные свойства и методы.

    // Вслед за объявлениями переменных можно поместить программный код инициализации модуля, который будет вызываться
    // всего один раз

    // Окончательный результат  – объект, возвращаемый немедленно вызываемой функцией, содержащий общедоступные члены модуля
    return {
        inArray: function (needle, haystack) {
            // ...
        },
        isArray: function (a) {
            // ...
        }
    };
}());


MYAPP.utilities.array = (function () {

        // В самом начале немедленно вызываемой функции следует поместить все объявления зависимостей, необходимых для модуля.
        // зависимости
    var uobj = MYAPP.utilities.object,
        ulang = MYAPP.utilities.lang,

        // В частной области видимости, образуемой немедленно вызываемой функцией, можно объявить частные свойства и методы.
        // частные свойства
        array_string = '[object Array]',
        ops = Object.prototype.toString;

        // частные методы
        // ...

        // конец инструкции var

    // Вслед за объявлениями переменных можно поместить программный код инициализации модуля, который будет вызываться
    // всего один раз
    // реализация необязательной процедуры инициализации
    // ...


    // Окончательный результат  – объект, возвращаемый немедленно вызываемой функцией, содержащий общедоступные члены модуля
    // общедоступные члены
    return {
        inArray: function (needle, haystack) {
            for (var i = 0, max = haystack.length; i < max; i += 1) {
                if (haystack[i] === needle) {
                    return true;
                }
            }
        },
        isArray: function (a) {
            return ops.call(a) === array_string;
        }
        // ... другие методы и свойства
    };
}());


// Шаблон «модуль» может быть модифицирован с применением шаблона открытия, когда все методы модуля являются частными
// и в конце определения модуля принимается решение, к каким из них следует открыть доступ.
MYAPP.utilities.array = (function () {
        // частные свойства
    var array_string = '[object Array]',
        ops = Object.prototype.toString,
        // частные методы
        inArray = function (haystack, needle) {
            for (var i = 0, max = haystack.length; i < max; i += 1) {
                if (haystack[i] === needle) {
                    return i;
                }
            }
            return -1;
        },
        isArray = function (a) {
            return ops.call(a) === array_string;
        };
    // конец инструкции var

    // открытие доступа к некоторым методам
    return {
        isArray: isArray,
        indexOf: inArray
    };
}());


// Иногда удобнее создавать объекты с помощью конструкторов. Для этой цели также можно использовать шабон «модуль».
// Единственное отличие состоит в том, что немедленно вызываемая функция, обертывающая модуль, возвращает функцию,
// а не объект.
MYAPP.namespace('MYAPP.utilities.Array');
MYAPP.utilities.Array = (function () {
        // зависимости
    var uobj = MYAPP.utilities.object,
        ulang = MYAPP.utilities.lang,
        // частные свойства и методы...
        Constr;
    // конец инструкции var

    // реализация необязательной процедуры инициализации
    // ...

    // общедоступные методы -- конструктор
    Constr = function (o) {
        this.elements = this.toArray(o);
    };

    // общедоступные методы -- прототип
    Constr.prototype = {
        constructor: MYAPP.utilities.Array,
        version: '2.0',
        toArray: function (obj) {
            for (var i = 0, a = [], len = obj.length; i < len; i += 1) {
                a[i] = obj[i];
            }
            return a;
        }
    };

    // вернуть конструктор,
    // создающий новое пространство имен
    return Constr;
}());

var arr = new MYAPP.utilities.Array(obj);

// В одной из распространенных разновидностей шаблона предусматривается возможность передачи аргументов в немедленно
// вызываемую функцию, обертывающую модуль. Функции можно передавать любые значения, но на практике ей обычно передаются
// ссылки на глобальные переменные и  иногда даже сам глобальный объект. Импортирование глобальных переменных позволяет
// увеличить скорость разрешения глобальных имен внутри немедленно вызываемой функции благодаря тому, что импортируемые
// переменные становятся локальными для этой функции:

MYAPP.utilities.module = (function (app, global) {
    // ссылки на объект global
    // и на глобальное пространство имен app
    // теперь будут локальными переменными
}(MYAPP, this));


/* ==================== Шаблон изолированного пространства имен ===================================================== */

// Шаблон изолированного пространства имен предоставляет каждому модулю окружение, изолированное от других модулей и их
// пространств имен.

// В шаблоне изолированного пространства имен единственным глобальным объектом является конструктор: назовем его Sandbox().
// Этот конструктор используется для создания объектов пространств имен и принимает функцию обратного вызова, которая
// будет играть роль изолированного окружения для вашего программного кода.

new Sandbox(function (box) {
    // здесь находится ваш программный код...
});

// Объект box  – это аналог объекта MYAPP в шаблоне пространства имен; он должен включать все библиотеки, необходимые
// для работы вашего программного кода.
// Конструктор Sandbox() может принимать дополнительные аргументы с настройками, определяющие имена модулей, необходимых
// для работы этого экземпляра объекта. Мы ставим своей целью добиться модульности кода, поэтому вся функциональность,
// обеспечиваемая конструктором Sandbox(), будет распределена по модулям.

Sandbox(['ajax', 'event'], function (box) {
    // console.log(box);
});

Sandbox('ajax', 'dom', function (box) {
    // console.log(box);
});

Sandbox('*', function (box) {
    // console.log(box);
});
Sandbox(function (box) {
    // console.log(box);
});

// Добавление модулей.
// Функция-конструктор Sandbox() кроме всего прочего является еще и объектом, поэтому мы можем добавить к ней статическое
// свойство с  именем modules. Это свойство будет еще одним объектом, содержащим пары ключ-значение, где ключами будут
// служить имена модулей, а значениями – функции, реализующие отдельные модули: Sandbox.modules = {};
// Функции, реализующие модули, принимают текущий экземпляр box в качестве параметра и могут добавлять дополнительные
// свойства и методы к этому экземпляру.
Sandbox.modules.dom = function (box) {
    box.getElement = function () {};
    box.getStyle = function () {};
    box.foo = 'bar';
};
Sandbox.modules.event = function (box) {
    // при необходимости к прототипу Sandbox можно обратиться так:
    // box.constructor.prototype.m = 'mmm';
    box.attachEvent = function () {};
    box.detachEvent = function () {};
};
Sandbox.modules.ajax = function (box) {
    box.makeRequest = function () {};
    box.getResponse = function () {};
};

// Реализация функции-конструктора
// - Проверка того, указывает ли ссылка this на экземпляр Sandbox, и если нет (когда функция Sandbox() вызывается без
// оператора new), то вызвать функцию как конструктор.
// - Внутри конструктора допускается добавлять новые свойства к объекту this. Точно так же допускается добавлять свойства
// к прототипу конструктора.
// - Информация о необходимых модулях может передаваться в виде массива имен, в виде отдельных аргументов или в виде
// аргумента со значением '*' (это значение используется по умолчанию в случае отсутствия аргумента), означающего, что
// необходимо включить все имеющиеся модули.
// - Определившись с перечнем необходимых модулей, мы инициализируем их, то есть вызываем функции, реализующие модули.
// - Последний аргумент конструктора – функция обратного вызова. Эта функция вызывается сразу после создания нового
// экземпляра объекта. Она играет роль изолированного пространства имен и получает объект box,
// заполненный всей необходимой функциональностью.
function Sandbox() {
        // преобразовать аргументы в массив
    var args = Array.prototype.slice.call(arguments),
        // последний аргумент - функция обратного вызова
        callback = args.pop(),
        // имена модулей могут передаваться в форме массива
        // или в виде отдельных параметров
        modules = (args[0] && typeof args[0] === 'string') ? args : args[0],
        i;

    // проверить, была ли функция вызвана
    // как конструктор
    if (!(this instanceof Sandbox)) {
        return new Sandbox(modules, callback);
    }
    // добавить свойства к объекту 'this', если это необходимо:
    this.a = 1;
    this.b = 2;

    // добавить модули в базовый объект 'this'
    // отсутствие аргументов с именами модулей или аргумент со значением '*'
    // предполагает необходимость включения всех модулей
    if (!modules || modules === '*') {
        modules = [];
        for (i in Sandbox.modules) {
            if (Sandbox.modules.hasOwnProperty(i)) {
                modules.push(i);
            }
        }
    }

    // инициализировать необходимые модули
    for (i = 0; i < modules.length; i += 1) {
        Sandbox.modules[modules[i]](this);
    }

    // вызвать функцию обратного вызова
    callback(this);
}

// добавить свойства к прототипу, если это необходимо
Sandbox.prototype = {
    name: 'My Application',
    version: '1.0',
    getName: function () {
        return this.name;
    }
};





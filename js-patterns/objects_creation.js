/**
 * Объекты. Создание объектов
 *
 */

/*
 Объект в JavaScript - хеш-таблица (ассоциативный массив), содержащая пары ключ-значение.
 */

/* ==================== Создание объектов =========================================================================== */

/* ==================== Способ 1. Создание пустого объекта в виде литерала ========================================== */

// В действительности в JavaScript нет пустых объектов. Даже простейший объект {} уже имеет свойства и методы,
// унаследованные от Object.prototype. Под "пустым" мы подразумеваем объект, не имеющий других свойств, кроме унаследованных.
var dog = {};

// Добавление свойства в объект
dog.name = 'Benji';

// Добавление метода в объект
dog.getName = function () {
    return dog.name;
};

/* ==================== Способ 2. Создание объектов с помощью конструкторов ========================================= */

// Есть возможностьсоздавать объекты, используя свои собственные функции-конструкторы или встроенные конструкторы,
// такие как Object(), Date(), String()...
var car = new Object(); //антишаблон
car.goes = 'far';

// Конструктор Object() может принимает параметр и в зависимости от его значения может делегировать создание объекта
// другому встроенному конструктору, вернув в результате объект не того типа, который вы ожидаете.
var o = new Object('I am a string');
console.log(o.constructor === String);// true

/* ==================== Собственные функции-конструкторы ===========================================================  */
// var Person = function (0) {
var Person = function (name) {

    // В момент создания объекта через new
    // здесь неявно создается пустой объект, наследующий свойства и методы прототи-па функции Person,
    // и ссылка на него сохраняется в переменой this.
    // var this = {};

    // Добавление новых свойств и методов в объект осуществляется с помощью ссылки this
    this.name = name;
    // Если метод say() добавить к ссылке this, тогда при каждом вызове конструктора new Person()
    // в памяти будет создаваться новая функция. Это неэкономно
//    this.say = function () {
//        return 'I am ' + this.name;
//    };

    // В конце функция неявно возвращает объект, на который ссылается переменная this
    // (если явно не возвращается никакой другой объект).
    // return this;

};

// Члены, общие для всех экземпляров, такие как методы, следует добавлять к прототипу.
Person.prototype.say = function () {
    return 'I am ' + this.name;
};

var adam = new Person('Adam');
adam.say(); // 'I am Adam'
console.log(adam);

/* ==================== Использование функции-конструктора без new ================================================== */

// Если вызвать конструктор без оператора new, ссылка this внутри конструктора будет указывать на глобальный объект.
// (В броузерах ссылка this указывает на объект window.)
// Если в  конструкторе создается какое-либо новое свойство, такое как this.member, то при вызове конструктора
// без оператора new будет создано новое свойство member глобального объекта, к  которому можно будет обратиться так:
// window.member или просто member. Такое поведение конструктора является крайне нежелательным, потому что вы всегда
// должны бороться за чистоту глобального пространства имен.

// конструктор
function Waffle() {
    // this - window
    this.tastes = 'yummy';
}
// новый объект
var good_morning = new Waffle();
console.log(typeof good_morning); // 'object'
console.log(good_morning.tastes); // 'yummy'

// антишаблон: пропущен оператор new
var good_morning = Waffle();
console.log(typeof good_morning); // 'undefined'
console.log(window.tastes); // 'yummy'

/* ==================== Одиннаковое поведение функции-конструктора при вызове с new и без =========================== */

// В конструкторе можно проверить, является ли ссылка this экземпляром конструктора, и если не является,
// вызвать конструктор еще раз, но уже с оператором new:

function Waffle() {
    if (!(this instanceof Waffle)) {
        return new Waffle();
    }
    // Другой распространенный способ проверки экземпляра состоит в том,
    // чтобы сравнить не с конкретным именем конструктора, а со свойством arguments.callee,
    // которое ссылается на вызываемую функцию

    if (!(this instanceof arguments.callee)) {
        return new arguments.callee();
    }


    this.tastes = 'yummy';
}
Waffle.prototype.wantAnother = true;
// проверка вызовов
var first = new Waffle(), // с new
    second = Waffle(); // без new
console.log(first.tastes); // 'yummy'
console.log(second.tastes); // 'yummy'
console.log(first.wantAnother); // true
console.log(second.wantAnother); // true








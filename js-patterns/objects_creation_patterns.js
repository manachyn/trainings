/**
 * Объекты. Создание объектов
 *
 */

/*
 Объекты создаются либо через литералы объектов либо вызовом функции-конструктора.
 */


/* ==================== Пространство имен =========================================================================== */

// Желательно создаватиь как можно меньше глобальных переменных. Можно создать один (в идеале только один)
// глобальный объект, который будет служить пространством имен для приложения или библиотеки.

// глобальный объект
var MYAPP = {};
// конструкторы
MYAPP.Parent = function () {};
MYAPP.Child = function () {};
// переменная
MYAPP.some_var = 1;
// объект-контейнер
MYAPP.modules = {};
// вложенные объекты
MYAPP.modules.module1 = {};
MYAPP.modules.module1.data = {a: 1, b: 2};
MYAPP.modules.module2 = {};

// Недостатки:
// - Увеличивается объем кода.
// - Наличие единственного экземпляра глобального объекта подразумевает, что любая часть программного кода может внести
// в него изменения, при этом остальная часть программного кода будет пользоваться измененным объектом.
// - Удлинение имен вложенных переменных подразумевает увеличение времени, необходимого на разрешение имен.


// Фрагменты кода могут быть в отдельных файлах. Поэтому, прежде чем добавлять свойство или создавать пространство имен,
// желательно убедиться, что оно еще не создано

if (typeof MYAPP === 'undefined') {
    var MYAPP = {};
}
// или немного короче
var MYAPP = MYAPP || {};

/* ==================== Функция создания пространства имен ========================================================== */

var MYAPP = MYAPP || {};
MYAPP.namespace = function (ns_string) {
    var parts = ns_string.split('.'),
        parent = MYAPP,
        i;
    // отбросить начальный префикс – имя глобального объекта
    if (parts[0] === 'MYAPP') {
        parts = parts.slice(1);
    }
    for (i = 0; i < parts.length; i += 1) {
        // создать свойство, если оно отсутствует
        if (typeof parent[parts[i]] === 'undefined') {
            parent[parts[i]] = {};
        }
        parent = parent[parts[i]];
    }
    return parent;
};

var module2 = MYAPP.namespace('MYAPP.modules.module2');
module2 === MYAPP.modules.module2; // true
MYAPP.namespace('modules.module51');


/* ==================== Зависимости ================================================================================= */
// Зависимости лучше объявлять в начале функции(области видимости)
// Зависимости лучше пересохранять в локальные переменные
// Примущества
// - Объявление в начале функции упрощает поиск и разрешение зависимостей.
// - Операции с локальными переменными (такими как dom) всегда выполняются быстрее, чем с глобальными (такими как YAHOO),
// и даже быстрее, чем с  вложенными свойствами глобальной переменной (такими как YAHOO.util.Dom),
// поэтому их использование позволяет увеличить производительность. Применение шаблона объявления зависимостей позволяет
// выполнять разрешение глобальных имен в функции только один раз. После этого везде в функции будет использоваться
// локальная переменная, обеспечивая более высокую скорость выполнения.
// - Некоторые компрессоры способны переименовывать(сжимать) локальные переменные, уменьшая объем кода, но они никогда
// не переименовывают глобальные переменные, потому что это небезопасно.

var myFunction = function () {
    // зависимости
    var event = YAHOO.util.Event,
        dom = YAHOO.util.Dom;

    // остальная часть функции
    // использует переменные event и dom...
};


/* ==================== Private переменные в функциях-конструкторах ================================================= */
function Gadget() {
    // частный член
    var name = 'Pod';

    // общедоступная функция
    this.getName = function () {
        return name;
    };
}
var toy = new Gadget();
// имя 'name' не определено, частный член
console.log(toy.name); // undefined
// общедоступный метод может обратиться к частному члену 'name'
console.log(toy.getName()); // 'iPod'

// Но если часная переменная является объектом или массивом, внешний программный код сможет изменить ее,
// потому что объекты и массивы передаются по ссылке.

function Gadget() {
    // частный член
    var specs = {
        screen_width: 320,
        screen_height: 480,
        color: 'white'
    };

    // общедоступная функция
    this.getSpecs = function () {
        return specs;
    };
}

var toy = new Gadget(),
specs = toy.getSpecs();
// Меняем часную переменную
specs.color = 'black';
specs.price = 'free';
console.dir(toy.getSpecs());

// Чтобы избежать этого неожиданного эффекта, не следует возвращать ссылки на объекты и массивы, которые должны
// оставаться частными.
// Способ 1 - в методе getSpecs() создавать и возвращать новый объект, содержащий только те данные, которые могут
// представлять интерес для получателя этого объекта.
// Способ 2 - создать и вернуть копию объекта


/* ==================== Private переменные в объектах определенных через литерал ==================================== */
var myobj; // это будет объект
(function () {
    // частные члены
    var name = 'my, oh my';
    // реализация общедоступных членов
    // обратите внимание на отсутствие инструкции 'var'
    myobj = {
    // привилегированный метод
        getName: function () {
            return name;
        }
    };
}());
myobj.getName(); // 'my, oh my'

// Более удобная форма записи примера выше
var myobj = (function () {
    // частные члены
    var name = 'my, oh my';
    // реализация общедоступных членов
    return {
        getName: function () {
            return name;
        }
    };
}());
myobj.getName(); // 'my, oh my'

/* ==================== Private переменные и прототипы ============================================================== */
// Один из недостатков создания частных членов с применением конструкторов заключается в том, что они создаются всякий раз,
// когда вызывается конструктор для создания нового объекта. Фактически эта проблема относится ко всем членам,
// добавляемым внутри конструкторов. Чтобы сэкономить свои усилия и память, общие для всех экземпляров свойства и методы
// можно добавить в свойство prototype конструктора.

function Gadget() {
    // частный член
    var name = 'iPod';
    // общедоступная функция
    this.getName = function () {
        return name;
    };
}
Gadget.prototype = (function () {
    // частный член
    var browser = 'Mobile Webkit';
    // общедоступные члены прототипа
    return {
        getBrowser: function () {
            return browser;
        }
    };
}());
var toy = new Gadget();
console.log(toy.getName()); // 'собственный' привилегированный метод
console.log(toy.getBrowser()); // привилегированный метод прототипа


// Здесь есть две частные переменные и  две частные функции, isArray() и indexOf(). В конце немедленно вызываемой
// функции объект myarray заполняется функциональными возможностями, доступ к которым требуется открыть.
// В данном случае одно и то же частное свойство indexOf() открывается под двумя разными именами: indexOf в стиле
// ECMAScript 5 и inArray в духе языка PHP.
var myarray;
(function () {
    var astr = '[object Array]',
    toString = Object.prototype.toString;
    function isArray(a) {
        return toString.call(a) === astr;
    }
    function indexOf(haystack, needle) {
        var i = 0,
            max = haystack.length;
        for (; i < max; i += 1) {
            if (haystack[i] === needle) {
                return i;
            }
        }
        return -1;
    }
    myarray = {
        isArray: isArray,
        indexOf: indexOf,
        inArray: indexOf
    };
}());






